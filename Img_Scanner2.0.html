<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Image Scan Analyzer</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>

<style>
    body {
        background: #ffffff;
        color: #333333;
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 20px;
    }
    button {
        padding: 8px 16px;
        margin-right: 10px;
        margin-bottom: 10px;
        font-size: 14px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        color: white;
    }
    #uploadBtn { background:#3498db; }
    #runBtn { background:#2ecc71; }
    #stopBtn { background:#e74c3c; }
    .labelText {
        font-size: 14px;
        margin-top: -5px;
        margin-bottom: 10px;
        color: #666;
    }
</style>

</head>
<body>

<button id="uploadBtn">Upload Image</button>
<div class="labelText">Upload an image to scan it</div>

<button id="runBtn">Run Scan</button>
<button id="stopBtn">Stop</button>

<script>

let img;
let input;
let scanning = false;
let stopRequested = false;

let horizIndex = 0;
let vertIndex = 0;

let horizColors = [];
let horizLightness = [];

let vertColors = [];
let vertLightness = [];

let horizPalette = [];
let vertPalette = [];

const GRAPH_HEIGHT = 70;      // Height of horizontal bars
const VGRAPH_WIDTH = 70;      // Width of vertical bars
const PALETTE_SIZE = 5;       // Number of colors to extract

function setup() {
    // Canvas sized to fit the image + 3 bars (Color, Lightness, Palette)
    let cnv = createCanvas(1200, 800); 
    cnv.position(20, 120);
    textAlign(CENTER, CENTER);
    noSmooth();

    input = createFileInput(handleFile);
    input.hide();

    document.getElementById("uploadBtn").onclick = () => input.elt.click();
    document.getElementById("runBtn").onclick = startScan;
    document.getElementById("stopBtn").onclick = requestStop;
}

function handleFile(file) {
    if (file.type === "image") {
        img = loadImage(file.data, () => {
            resetAll();
        });
    }
}

function resetAll() {
    horizIndex = 0;
    vertIndex = 0;
    scanning = false;
    stopRequested = false;
    horizColors = [];
    horizLightness = [];
    vertColors = [];
    vertLightness = [];
    horizPalette = [];
    vertPalette = [];
    redraw();
}

function requestStop() {
    stopRequested = true;
}

function startScan() {
    if (!img) return;
    resetAll();
    scanning = true;
}

function draw() {
    background(255); 
    noStroke(); 

    if (!img) {
        fill(150);
        text("No image uploaded", width / 2, height / 2);
        return;
    }

    // Draw image (Main Reference)
    image(img, 20, 20, 600, 400);

    let imgW = img.width;
    let imgH = img.height;

    // -----------------------------
    // SCAN PROCESSING
    // -----------------------------
    if (scanning && !stopRequested) {
        // Horizontal Scan
        if (horizIndex < imgW) {
            scanHorizontalColumn(horizIndex);
            horizIndex++;
        }
        
        // Vertical Scan (starts after Horizontal is done)
        if (horizIndex >= imgW && vertIndex < imgH) {
            scanVerticalRow(vertIndex);
            vertIndex++;
        }

        // Finish
        if (vertIndex === imgH) {
            scanning = false;
        }
    }

    // -----------------------------
    // REAL-TIME PALETTE CALCULATION
    // -----------------------------
    if (horizColors.length > 0) {
        horizPalette = generatePalette(horizColors, PALETTE_SIZE);
    }
    if (vertColors.length > 0) {
        vertPalette = generatePalette(vertColors, PALETTE_SIZE);
    }

    // -----------------------------
    // DRAW GRAPHS & PALETTES
    // -----------------------------
    
    // -- 1. Horizontal Group (Below Image) --
    let hGraphY1 = 440; // Top of first graph
    
    // H-Color Graph
    drawHorizontalColorGraph(20, hGraphY1);
    
    // H-Lightness Graph
    drawHorizontalLightnessGraph(20, hGraphY1 + GRAPH_HEIGHT + 10);
    
    // H-Palette Bar (New: Full width bar)
    drawBarPalette(
        20, 
        hGraphY1 + (GRAPH_HEIGHT + 10) * 2, // Positioned below lightness
        600,            // Width matches image
        GRAPH_HEIGHT,   // Height matches other graphs
        horizPalette, 
        true            // isHorizontal = true
    );


    // -- 2. Vertical Group (Right of Image) --
    let vGraphX1 = 640; // Left of first graph
    
    // V-Color Graph
    drawVerticalColorGraph(vGraphX1, 20);
    
    // V-Lightness Graph
    drawVerticalLightnessGraph(vGraphX1 + VGRAPH_WIDTH + 10, 20);
    
    // V-Palette Bar (New: Full height bar)
    drawBarPalette(
        vGraphX1 + (VGRAPH_WIDTH + 10) * 2, // Positioned right of lightness
        20, 
        VGRAPH_WIDTH,   // Width matches other graphs
        400,            // Height matches image
        vertPalette, 
        false           // isHorizontal = false
    );

    // -----------------------------
    // SCAN LINE ANIMATION
    // -----------------------------
    drawScanLines();
}

//
// ----- SCAN LOGIC ----
//
function scanHorizontalColumn(x) {
    let hist = {};
    let lightsum = 0;

    for (let y = 0; y < img.height; y++) {
        let c = img.get(x, y);
        let key = `${c[0]},${c[1]},${c[2]}`;
        hist[key] = (hist[key] || 0) + 1;
        lightsum += (c[0] + c[1] + c[2]) / 3 / 255;
    }

    let dominant = Object.keys(hist).reduce((a, b) => hist[a] > hist[b] ? a : b);
    let lightness = lightsum / img.height;

    let rgb = dominant.split(',').map(v => int(v));
    horizColors[x] = rgb;
    horizLightness[x] = lightness;
}

function scanVerticalRow(y) {
    let hist = {};
    let lightsum = 0;

    for (let x = 0; x < img.width; x++) {
        let c = img.get(x, y);
        let key = `${c[0]},${c[1]},${c[2]}`;
        hist[key] = (hist[key] || 0) + 1;
        lightsum += (c[0] + c[1] + c[2]) / 3 / 255;
    }

    let dominant = Object.keys(hist).reduce((a, b) => hist[a] > hist[b] ? a : b);
    let lightness = lightsum / img.width;

    let rgb = dominant.split(',').map(v => int(v));
    vertColors[y] = rgb;
    vertLightness[y] = lightness;
}

//
// ---- GRAPH DRAWING ----
//
function drawHorizontalColorGraph(gx, gy) {
    for (let x = 0; x < horizColors.length; x++) {
        let c = horizColors[x];
        if (c) {
            fill(c[0], c[1], c[2]);
            rect(gx + map(x, 0, img.width, 0, 600), gy, 1, GRAPH_HEIGHT);
        }
    }
}

function drawHorizontalLightnessGraph(gx, gy) {
    for (let x = 0; x < horizLightness.length; x++) {
        let l = horizLightness[x];
        if (l !== undefined) {
            let h = l * GRAPH_HEIGHT;
            fill(l * 255);
            rect(gx + map(x, 0, img.width, 0, 600), gy + GRAPH_HEIGHT - h, 1, h);
        }
    }
}

function drawVerticalColorGraph(gx, gy) {
    for (let y = 0; y < vertColors.length; y++) {
        let c = vertColors[y];
        if (c) {
            fill(c[0], c[1], c[2]);
            rect(gx, gy + map(y, 0, img.height, 0, 400), VGRAPH_WIDTH, 1);
        }
    }
}

function drawVerticalLightnessGraph(gx, gy) {
    for (let y = 0; y < vertLightness.length; y++) {
        let l = vertLightness[y];
        if (l !== undefined) {
            let w = l * VGRAPH_WIDTH;
            fill(l * 255);
            rect(gx, gy + map(y, 0, img.height, 0, 400), w, 1);
        }
    }
}

//
// ---- BAR PALETTE DRAWING (New) ----
//
function drawBarPalette(x, y, w, h, paletteArray, isHorizontal) {
    // If empty, draw placeholder outline
    if (!paletteArray || paletteArray.length === 0) {
        stroke(220);
        noFill();
        rect(x, y, w, h);
        noStroke();
        return;
    }

    // Determine size of each block based on orientation
    let step;
    if (isHorizontal) {
        step = w / paletteArray.length;
    } else {
        step = h / paletteArray.length;
    }

    for (let i = 0; i < paletteArray.length; i++) {
        let c = paletteArray[i];
        fill(c[0], c[1], c[2]);
        
        if (isHorizontal) {
            // Draw segments side-by-side
            rect(x + i * step, y, step, h);
        } else {
            // Draw segments top-to-bottom
            rect(x, y + i * step, w, step);
        }
    }
}

//
// ---- SCANNING LINE ANIMATION ----
//
function drawScanLines() {
    noFill();
    strokeWeight(3);

    if (horizIndex < img.width) {
        stroke(0, 255, 255); 
        let sx = 20 + map(horizIndex, 0, img.width, 0, 600);
        line(sx, 20, sx, 420);
    } else if (vertIndex < img.height) {
        stroke(0, 255, 255);
        let sy = 20 + map(vertIndex, 0, img.height, 0, 400);
        line(20, sy, 620, sy);
    }
}

//
// ---- PALETTE GENERATOR ----
//
function generatePalette(colorArray, count) {
    if (!colorArray || colorArray.length === 0) return [];

    let uniq = {};
    for (let c of colorArray) {
        if (!c) continue;
        let key = `${c[0]},${c[1]},${c[2]}`;
        uniq[key] = (uniq[key] || 0) + 1;
    }

    let sorted = Object.entries(uniq)
        .sort((a, b) => b[1] - a[1])
        .slice(0, count)
        .map(v => v[0].split(',').map(n => int(n)));

    return sorted;
}

</script>

</body>
</html>